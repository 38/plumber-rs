/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
pub const _SYS_STAT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __time_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _MKNOD_VER: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const __PLUMBER_SOURCE_ROOT__: &'static [u8; 28usize] = b"/home/haohou/source/plumber\0";
pub const LOG_LEVEL: u32 = 3;
pub const LOG_DEFAULT_CONFIG_FILE: &'static [u8; 8usize] = b"log.cfg\0";
pub const CONFIG_PATH: &'static [u8; 25usize] = b"/home/haohou/etc/plumber\0";
pub const UTILS_THREAD_GENERIC_ALLOC_UNIT: u32 = 8;
pub const RUNTIME_SERVLET_DEFAULT_SEARCH_PATH: &'static [u8; 33usize] =
    b"/home/haohou/lib/plumber/servlet\0";
pub const RUNTIME_SERVLET_TAB_INIT_SIZE: u32 = 32;
pub const RUNTIME_SERVLET_NS1_PREFIX: &'static [u8; 22usize] = b"/tmp/plumber-servlet.\0";
pub const RUNTIME_SERVLET_NAME_LEN: u32 = 128;
pub const RUNTIME_PIPE_NAME_LEN: u32 = 128;
pub const RUNTIME_PDT_INIT_SIZE: u32 = 8;
pub const SCHED_SERVICE_BUFFER_NODE_LIST_INIT_SIZE: u32 = 32;
pub const SCHED_SERVICE_BUFFER_OUT_GOING_LIST_INIT_SIZE: u32 = 8;
pub const SCHED_SERVICE_MAX_NUM_NODES: u32 = 1048576;
pub const SCHED_SERVICE_MAX_NUM_EDGES: u32 = 16777216;
pub const SCHED_TASK_TABLE_SLOT_SIZE: u32 = 37813;
pub const DO_NOT_COMPILE_ITC_MODULE_TEST: u32 = 0;
pub const ITC_MODULE_EVENT_QUEUE_SIZE: u32 = 128;
pub const ITC_MODULE_CALLBACK_READ_BUF_SIZE: u32 = 4096;
pub const ITC_EQUEUE_VEC_INIT_SIZE: u32 = 4;
pub const LANG_LEX_SEARCH_LIST_INIT_SIZE: u32 = 4;
pub const RUNTIME_SERVLET_SEARCH_PATH_INIT_SIZE: u32 = 4;
pub const LANG_BYTECODE_HASH_SIZE: u32 = 10093;
pub const LANG_BYTECODE_LABEL_VECTOR_INIT_SIZE: u32 = 32;
pub const LANG_BYTECODE_LIST_INIT_SIZE: u32 = 4096;
pub const LANG_BYTECODE_HASH_POOL_INIT_SIZE: u32 = 4096;
pub const LANG_COMPILER_NODE_HASH_SIZE: u32 = 10093;
pub const LANG_COMPILER_NODE_HASH_POOL_INIT_SIZE: u32 = 4096;
pub const LANG_VM_ENV_HASH_SIZE: u32 = 1023;
pub const LANG_VM_ENV_POOL_INIT_SIZE: u32 = 4096;
pub const LANG_VM_PARAM_INIT_SIZE: u32 = 32;
pub const LANG_LEX_FILE_BUF_INIT_SIZE: u32 = 4096;
pub const LANG_PROP_CALLBACK_VEC_INIT_SIZE: u32 = 32;
pub const SCHED_LOOP_EVENT_QUEUE_SIZE: u32 = 4096;
pub const SCHED_LOOP_MAX_PENDING_TASKS: u32 = 1048576;
pub const ITC_MODTAB_MAX_PATH: u32 = 4096;
pub const SCHED_CNODE_BOUNDARY_INIT_SIZE: u32 = 8;
pub const SCHED_PROF_INIT_THREAD_CAPACITY: u32 = 1;
pub const PSCRIPT_GLOBAL_MODULE_PATH: &'static [u8; 29usize] = b"/home/haohou/lib/plumber/pss\0";
pub const SCHED_RSCOPE_ENTRY_TABLE_INIT_SIZE: u32 = 4096;
pub const SCHED_RSCOPE_ENTRY_TABLE_SIZE_LIMIT: u32 = 1048576;
pub const SCHED_TYPE_ENV_HASH_SIZE: u32 = 97;
pub const SCHED_TYPE_MAX: u32 = 65536;
pub const SCHED_DAEMON_MAX_ID_LEN: u32 = 128;
pub const SCHED_DAEMON_FILE_PREFIX: &'static [u8; 16usize] = b"var/run/plumber\0";
pub const SCHED_DAEMON_SOCKET_SUFFIX: &'static [u8; 6usize] = b".sock\0";
pub const SCHED_DAEMON_LOCK_SUFFIX: &'static [u8; 6usize] = b".lock\0";
pub const SCHED_DAEMON_PID_SUFFIX: &'static [u8; 5usize] = b".pid\0";
pub const TEST_PROTODB_ROOT: &'static [u8; 56usize] =
    b"/home/haohou/source/build.plumber/bin/test/protodb.root\0";
pub const INSTALL_PREFIX: &'static [u8; 13usize] = b"/home/haohou\0";
pub const MODULE_TLS_ENABLED: u32 = 1;
pub const MODULE_TCP_MAX_ASYNC_BUF_SIZE: u32 = 4096;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const RUNTIME_SERVLET_FILENAME_PREFIX: &'static [u8; 4usize] = b"lib\0";
pub const RUNTIME_SERVLET_FILENAME_SUFFIX: &'static [u8; 4usize] = b".so\0";
pub const UNTYPED_PIPE_HEADER: &'static [u8; 17usize] = b"plumber/base/Raw\0";
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_GET_FLAGS: u32 = 4278190080;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_SET_FLAG: u32 = 4278190081;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_CLR_FLAG: u32 = 4278190082;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_EOM: u32 = 4278190083;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_PUSH_STATE: u32 = 4278190084;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_POP_STATE: u32 = 4278190085;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_INVOKE: u32 = 4278190086;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_READHDR: u32 = 4278190087;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_WRITEHDR: u32 = 4278190088;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_MODPATH: u32 = 4278190089;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_GET_HDR_BUF: u32 = 4278190090;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_GET_DATA_BUF: u32 = 4278190091;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_PUT_DATA_BUF: u32 = 4278190092;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_NOP: u32 = 4294967294;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_SET_WAIT: u32 = 0;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_NOTIFY_WAIT: u32 = 1;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_RETCODE: u32 = 2;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_CANCEL: u32 = 3;
pub const PIPE_CNTL_GET_FLAGS: u32 = 4278190080;
pub const PIPE_CNTL_SET_FLAG: u32 = 4278190081;
pub const PIPE_CNTL_CLR_FLAG: u32 = 4278190082;
pub const PIPE_CNTL_EOM: u32 = 4278190083;
pub const PIPE_CNTL_PUSH_STATE: u32 = 4278190084;
pub const PIPE_CNTL_POP_STATE: u32 = 4278190085;
pub const PIPE_CNTL_INVOKE: u32 = 4278190086;
pub const PIPE_CNTL_READHDR: u32 = 4278190087;
pub const PIPE_CNTL_WRITEHDR: u32 = 4278190088;
pub const PIPE_CNTL_MODPATH: u32 = 4278190089;
pub const PIPE_CNTL_GET_HDR_BUF: u32 = 4278190090;
pub const PIPE_CNTL_GET_DATA_BUF: u32 = 4278190091;
pub const PIPE_CNTL_PUT_DATA_BUF: u32 = 4278190092;
pub const PIPE_CNTL_NOP: u32 = 4294967294;
pub const ASYNC_CNTL_SET_WAIT: u32 = 0;
pub const ASYNC_CNTL_NOTIFY_WAIT: u32 = 1;
pub const ASYNC_CNTL_RETCODE: u32 = 2;
pub const ASYNC_CNTL_CANCEL: u32 = 3;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const PIPE_MAX_NAME: u32 = 1024;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type ino_t = __ino_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type uid_t = __uid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(
        __ver: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(
        __ver: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
/// @brief the type used to the pipe ID
pub type runtime_api_pipe_id_t = u16;
/// @brief the type used to represent a pipe object, either a real pipe or a reference
/// to a module function
/// @note there are two different memory layout for this type <br/>
/// a) 11111111 00000000 pppppppp pppppppp <br/>
/// This is used when we refer a pipe id <br/>
/// b) mmmmmmmm oooooooo oooooooo oooooooo <br/>
/// This is used when we refer a service module function
pub type runtime_api_pipe_t = u32;
/// @brief the type used for the pipe define flags
/// @note the bit layout of a pipe flags is  <br/>
/// rrrrrrrr rrrDsapd tttttttt tttttttt <br/>
/// D = disabled <br/>
/// s = Shadow Pipe <br/>
/// a = Async Pipe <br/>
/// r = Reserved <br/>
/// p = Presist  <br/>
/// d = Pipe direction <br/>
/// t = Target Pipe <br/>
pub type runtime_api_pipe_flags_t = u32;
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_flags_dir1 {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_flags_dir1() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_flags_dir1>(),
        0usize,
        concat!("Size of: ", stringify!(__const_checker_eq_flags_dir1))
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_flags_dir1>(),
        4usize,
        concat!("Alignment of ", stringify!(__const_checker_eq_flags_dir1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_flags_dir1>())).test as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_flags_dir1),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_flags_dir2 {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_flags_dir2() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_flags_dir2>(),
        0usize,
        concat!("Size of: ", stringify!(__const_checker_eq_flags_dir2))
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_flags_dir2>(),
        4usize,
        concat!("Alignment of ", stringify!(__const_checker_eq_flags_dir2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_flags_dir2>())).test as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_flags_dir2),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_flags_persist {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_flags_persist() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_flags_persist>(),
        0usize,
        concat!("Size of: ", stringify!(__const_checker_eq_flags_persist))
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_flags_persist>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_flags_persist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_flags_persist>())).test as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_flags_persist),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_get_flags__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_get_flags__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_get_flags__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_get_flags__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_get_flags__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_get_flags__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_get_flags__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_get_flags__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_set_flag__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_set_flag__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_set_flag__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_set_flag__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_set_flag__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_set_flag__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_set_flag__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_set_flag__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_clr_flag__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_clr_flag__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_clr_flag__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_clr_flag__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_clr_flag__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_clr_flag__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_clr_flag__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_clr_flag__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_eom__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_eom__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_eom__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_eom__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_eom__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_eom__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_eom__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_eom__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_push_state__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_push_state__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_push_state__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_push_state__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_push_state__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_push_state__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_push_state__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_push_state__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_pop_state__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_pop_state__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_pop_state__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_pop_state__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_pop_state__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_pop_state__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_pop_state__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_pop_state__),
            "::",
            stringify!(test)
        )
    );
}
/// @brief the token used to request local scope token
pub type runtime_api_scope_token_t = u32;
/// @brief The event description of the event driven scope stream. Which is actually a file descriptor and
/// when the file descriptor should be treated as the stream gets ready
/// If both read and write is 0, it means we want to remove the event from the module
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_scope_ready_event_t {
    /// < The FD that is used for event notification
    pub fd: ::std::os::raw::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    /// < The time limit for the RLS token not gets ready
    pub timeout: i32,
}
#[test]
fn bindgen_test_layout_runtime_api_scope_ready_event_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_scope_ready_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(runtime_api_scope_ready_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_scope_ready_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(runtime_api_scope_ready_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_ready_event_t>())).fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_ready_event_t),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_ready_event_t>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_ready_event_t),
            "::",
            stringify!(timeout)
        )
    );
}
impl runtime_api_scope_ready_event_t {
    #[inline]
    pub fn read(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(read: u32, write: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read: u32 = unsafe { ::std::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write: u32 = unsafe { ::std::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit
    }
}
/// @brief Represent an entity in the scope. It's actually a group of callback function for the opeartion
/// that is supported by the scope entity and a memory address which represent the entity data
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_scope_entity_t {
    /// < the actual pointer
    pub data: *mut ::std::os::raw::c_void,
    /// @brief the callback function used to copy the memory
    /// @param ptr the pointer to copy
    /// @return the copied pointer
    pub copy_func: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    /// @brief the callback used to dispose a managed pointer
    /// @note this is the only required callback for each RLS object
    /// @param ptr the pointer to dispose
    /// @return status code
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief the callback function used to open the rscope pointer as a byte stream
    /// @note this is the callback function is used to serialize the RLS memory info a
    /// byte stream. This feature is used for the framework to write a serialized
    /// RLS directly to the pipe, which means we do not needs high level user-space
    /// program to handle this. <br/>
    /// The reason for why we have this is, without this mechanism,
    /// when we build a file server, we need to read the file content into a mem pipe,
    /// and then copy the mem pipe to async buffer and then write it to the socket.
    /// Most of the operations are unncessary. By introducing the file RLS, and this
    /// byte stream interface, we will be able to read the file from the async write loop
    /// directly. In this way, we can elimite the memory copy completely. <br/>
    /// @param ptr the RLS pointer to open
    /// @return the byte stream handle, which is the state variable for the serialization, NULL on error case
    pub open_func: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    /// @brief read bytes from the byte stream representation of the RLS pointer
    /// @param handle the byte stream handle
    /// @param buffer the buffer to return the read result
    /// @param bufsize the buffer size
    /// @return the bytes has been read to buffer, or error code
    /// @note If this function returns 0, it may indicates the stream is waiting for resource gets ready
    /// In this case, if the user supports event driven interface, it may call event_func for the
    /// event description that hints the availibility of the stream.
    pub read_func: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_void,
            bufsize: usize,
        ) -> usize,
    >,
    /// @brief check if the byte stream representation of the RLS pointer has reached the end of stream (EOS)
    /// @param handle the byte stream handle
    /// @return the check result, 1 for true, 0 for false, error code on error cases
    pub eos_func: ::std::option::Option<
        unsafe extern "C" fn(handle: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief Get the event that should be used as the notification for the readiness of the stream
    /// @param handle The stream handle
    /// @param event_buf The buffer used to return the event
    /// @return Number of event has been registered, 0 if no event should be registered, 1 for needs to register one
    /// event and error code for all the error cases
    pub event_func: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            event_buf: *mut runtime_api_scope_ready_event_t,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief close a used stream handle
    /// @param handle the handle to close
    /// @note this function will dispose the memory occupied by the handle
    /// @return status code
    pub close_func: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_scope_entity_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_scope_entity_t>(),
        64usize,
        concat!("Size of: ", stringify!(runtime_api_scope_entity_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_scope_entity_t>(),
        8usize,
        concat!("Alignment of ", stringify!(runtime_api_scope_entity_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).copy_func as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(copy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).free_func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(free_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).open_func as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(open_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).read_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(read_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).eos_func as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(eos_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).event_func as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(event_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).close_func as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(close_func)
        )
    );
}
/// @brief describe the param for the request that ask for the write_token API consume the
/// token data in the way specified by this
/// @details Problem: This mechanism is used to address the problem that the directly RLS token access interface
/// is not buffer friendly. Consider we use an BIO object to write the pipe, so all the data that has written
/// to pipe via BIO is bufferred in the BIO buffer. After this, if we want to write a RLS token, the BIO buffer
/// has to flush no matter if it's full or not. <br/>
/// Because the write_token call do not aware of the BIO buffer, so it will write the data directly, however all
/// the bufferred BIO data which should be written before the token is now after the token content. <br/>
/// However, this additional flush causes serious problem. Because we have to flush the buffer once the write_token has
/// been called. For example, previously, we will be able to use the bio call like:
/// <code>
/// pstd_bio_printf("<div>%s</div>", file_content);
/// </code>
/// To write the response which will translate to 1 pipe_write of course, however, by introducing the DRA, we should use:
/// <code>
/// pstd_bio_printf("<div>");
/// pstd_bio_write_token(file_token);
/// pstd_bio_printf("</div>");
/// </code>
/// Which actually needs to translate to 3 pipe_write, which turns out to be 3 syscalls. <br/>
/// This causes a huge performance downgrade from 115K Req/sec to 68K req/sec for the user-agent echo back server.
/// Solution: This is the descriptor that request the first N bytes from the RLS token stream, and this data will be passed in
/// to the callback provided by the caller of write_token, by having this callback, the caller (which is PSTD BIO of course),
/// will have a last chance to fill the unused buffer. If the stream is exhuasted by the data request, no underlying DRA will
/// happen, otherwise, the DRA will handle the remaining portion of the stream. <br/>
/// If the data is exhuasted by the data request and BIO buffer is not full, then the buffer won't flush. In this way, we make
/// a full use of user-space buffer before we flush it.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_scope_token_data_request_t {
    /// < The number of bytes we are reqeusting
    pub size: usize,
    /// < The caller context of this data request
    pub context: *mut ::std::os::raw::c_void,
    /// @brief the callback function that handles the requested data, it may be called multiple times
    /// once the data_handler returns 0, then it means the data request do not want the data anymore
    /// @param context the caller defined context
    /// @param data the pointer to the data section
    /// @param count the number of bytes is available at this time
    /// @return the number of bytes handled by this call, if the return value is larger than 0 and the requested size
    /// limit not reach, then the remaning data from the token stream will keep sent to the handler, until
    /// it returns an error code or 0
    pub data_handler: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            data: *const ::std::os::raw::c_void,
            count: usize,
        ) -> usize,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_scope_token_data_request_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_scope_token_data_request_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(runtime_api_scope_token_data_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_scope_token_data_request_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(runtime_api_scope_token_data_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_token_data_request_t>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_token_data_request_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_token_data_request_t>())).context as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_token_data_request_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_token_data_request_t>())).data_handler
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_token_data_request_t),
            "::",
            stringify!(data_handler)
        )
    );
}
/// @brief The callback when the type of the pipe is determined
/// @param pipe the pipe descriptor
/// @param type_name the concrete type name of the pipe
/// @param data the addtional data passed to the callback, typically the servlet instance context
/// @return status code
pub type runtime_api_pipe_type_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        pipe: runtime_api_pipe_t,
        type_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// < This is a sync servlet
pub const RUNTIME_API_INIT_RESULT_SYNC: _bindgen_ty_1 = 0;
/// < This is an async servlet
pub const RUNTIME_API_INIT_RESULT_ASYNC: _bindgen_ty_1 = 1;
/// @brief The return value for the servlet's init function, which indicates the property of the servlet
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _runtime_api_async_task_handle_t {
    _unused: [u8; 0],
}
/// @brief This is the dummy type we used to make the compiler aware we are dealing with a async task handle
pub type runtime_api_async_handle_t = _runtime_api_async_task_handle_t;
/// @brief the address table that contains the address of the pipe APIs
/// @note we do not need the servlet instance id, because the caller of the exec of the init will definately have the execution info. <br/>
/// All the function defined in this place can only be called within the servlet context. <br/>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_address_table_t {
    /// @brief define a named pipe in the PDT of this servlet
    /// @details Define a IO pipe for a servlet. The function will define a pipe for a servlet.
    /// Which is actually either the input or the output end of a pipe. <br/>
    /// The function will return a integer called pipe descriptor. The pipe descriptor can be
    /// used later in the exec function of the servlet as the data source/sink. <br/>
    /// For the given servlet instance, once the instance is initialized, the servlet can not
    /// define the pipe anymore. <br/>
    /// The reason for why we need such limitation is the topologic structure of a service *must*
    /// be defined before the framework start serving traffic. Which means, we do not allow the
    /// node change it's layout after the initialization pharse. <br/>
    /// Also, the pipe can be defined with different properties. The properties can be changed at
    /// the execution pharse for *only that exuection*. Which means you can not preserve the pipe
    /// flags changed in execution phrase.
    /// @note This function must be called by the **init** function in servlet
    /// @param name the name to this pipe
    /// @param flag the flag to create this pipe
    /// @param type_expr the type expression for this pipe, if NULL is given, then this is a untyped pipe
    /// @return pipe id or a negative error code
    pub define: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            flag: runtime_api_pipe_flags_t,
            type_expr: *const ::std::os::raw::c_char,
        ) -> runtime_api_pipe_t,
    >,
    /// @brief setup the hook function when the type of pipe is determined. The reason for having this function is
    /// that we have some generic typed servlet. So the type of the pipe is depends on the context of the service
    /// graph, rather than the servlet itself. So that we do not know the concrete type of the generic pipe until
    /// we finished the type inference. <br/>
    /// However, we don't want to query the type info in exeuction time, because of the perofmrance consideration.
    /// So we should have some mechanism so that we can initialize the type specified information before the servlet
    /// actually started.
    /// @param callback the callback function pointer
    /// @param pipe     the pipe descriptor we want to set the callback
    /// @param data     the additional data to be passed to the callback function
    /// @note  Because the type inferrer only work on the assigned pipes, so even though the type of unassigned pipes are known
    /// the callback function won't be called.
    /// @return status code
    /// @todo implement this
    pub set_type_hook: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            callback: runtime_api_pipe_type_callback_t,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief read data from pipe
    /// @param pipe the pipe to read
    /// @param nbytes the number of bytes to read
    /// @param buffer the memory buffer for the read result
    /// @return either the number of bytes or the error code
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            buffer: *mut ::std::os::raw::c_void,
            nbytes: usize,
        ) -> usize,
    >,
    /// @brief write data to the given pipe
    /// @param pipe the pipe to write
    /// @param data the data buffer
    /// @param nbytes the number of bytes to write
    /// @return number of bytes has written
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            data: *const ::std::os::raw::c_void,
            nbytes: usize,
        ) -> usize,
    >,
    /// @brief write the content of a scope token to the pipe
    /// @details The detailed description can be found in the documentation of the module call write_callback
    /// @param pipe the pipe to write
    /// @param token the token
    /// @param data_req the data request callback, see the type documentation for the details about the data request mechanism.
    /// If the data request is not desired, pass just NULL. During this time, no pointer's ownership will be taken
    /// @note this function will make sure that all the bytes for this token is written to the pipe
    /// @return status code
    pub write_scope_token: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            token: runtime_api_scope_token_t,
            data_req: *const runtime_api_scope_token_data_request_t,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief write a log to the plumber logging system
    /// @param level the log level
    /// @param file  the source code file name
    /// @param function the function name
    /// @param line the line number
    /// @param fmt the formatting string
    /// @param ap the vaargs
    /// @return nothing
    pub log_write: ::std::option::Option<
        unsafe extern "C" fn(
            level: ::std::os::raw::c_int,
            file: *const ::std::os::raw::c_char,
            function: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            ap: *mut __va_list_tag,
        ),
    >,
    /// @brief trap is a function that makes the execution flow goes back to the Plumber framework
    /// @param id the trap id
    pub trap: ::std::option::Option<unsafe extern "C" fn(id: ::std::os::raw::c_int)>,
    /// @brief EOF check
    /// @param pipe the pipe id
    /// @return result or status code
    pub eof: ::std::option::Option<
        unsafe extern "C" fn(pipe: runtime_api_pipe_t) -> ::std::os::raw::c_int,
    >,
    /// @brief the pipe control API
    /// @note this function is used to control pipe behaviour, like POSIX API fcntl. This function
    /// modifies the current pipe instance only, and do not affect any other pipe instnaces.
    /// @param pipe the target pipe
    /// @param opcode what operation needs to be perfomed
    /// @param ap the va params
    /// @return the status code
    pub cntl: ::std::option::Option<
        unsafe extern "C" fn(pipe: runtime_api_pipe_t, opcode: u32, ap: *mut __va_list_tag)
            -> ::std::os::raw::c_int,
    >,
    /// @brief requires a module function handle pipe so that the servlet can call the service module
    /// @param mod_name the name of the service module function, e.g. "mempool.object_pool"
    /// @param func_name the name of the function we want, e.g. "allocate"
    /// @return the module type code
    pub get_module_func: ::std::option::Option<
        unsafe extern "C" fn(
            mod_name: *const ::std::os::raw::c_char,
            func_name: *const ::std::os::raw::c_char,
        ) -> runtime_api_pipe_t,
    >,
    /// @brief open a module by its name
    /// @param mod the name of the module
    /// @note this function must match the exact module path
    /// @return the module type code or error code
    pub mod_open:
        ::std::option::Option<unsafe extern "C" fn(mod_: *const ::std::os::raw::c_char) -> u8>,
    /// @brief get the 8bit prefix used for the module specified cntl opcode
    /// @param path the path to the module suffix, for example all the TLS module should use "pipe.tls"
    /// @param result the result prefix, if there's no module instace under the given path, the result will be set to ERROR_CODE(uint8_t)
    /// @note The reason why we need this function is: <br/>
    /// 1. The module is dynmaically loaded, so the module id is determined in runtime <br/>
    /// 2. The servlet API is module-implementation-transparent, which means we cannot put any pipe implementation specified code in the
    /// servlet code <br/>
    /// In some cases, we may have serveral module instatiated from the same module binary
    /// with different module initializtion param.
    /// In this case, if we need to call the module specified control opcode, we *have to* know
    /// the module id, because the opcode for module specified opcode is &lt;module-id, module-specfied-opcode&gt; <br/>
    /// The module id can be get from mod_open call, however, it requires a full path to the module instance. This
    /// makes the details of the pipe not transparent to the servlet. <br/>
    /// For example, in code we may want to disable the TLS encrpytion because of the oppurtunistic encryption.
    /// On the server which is configured the TLS module is listening to the port 443. With mod_open call, we have to
    /// make the code like:
    /// \code{.c}
    /// uint8_t mod = mod_open("pipe.tls.pipe.tcp.port_443");
    /// uint32_t opcode = (mod << 24) | (OPCODE_WE_WANT);
    /// pipe_cntl(pipe, opcode, ....);
    /// \endcode
    /// As we can see from the code, once the port gets changed, the servlet doesn't work anymore.
    /// So it's not pipe transparent. <br/>
    /// To address this issue, we actually use *one representitive of all the module instances that is initialized from the same module binary*.
    /// Because all the module binary are the same, so the ITC framework will be able to call the correct module binary.
    /// At the same time, because the pipe itself has a reference to the module instance context, so the call will be forwarded correctly. <br/>
    /// On the other hand, it's reasonable for all the module instance from same binary (e.g. all the TLS modules) to have the same opcode
    /// because it's reasonable to have all those module instances gets the same opcode. <br/>
    /// Based on the reason above we need the function that can return a "representitive module instance" for all the module which creates from the
    /// same module binary. <br/>
    /// In this function, we need assume that all the module instances under the given path are created from the same module binary.
    /// If this rule breaks, it will return an error code
    /// @return status code
    pub mod_cntl_prefix: ::std::option::Option<
        unsafe extern "C" fn(path: *const ::std::os::raw::c_char, result: *mut u8)
            -> ::std::os::raw::c_int,
    >,
    /// @brief get the plumber version number
    /// @return the plumber version number string, NULL on error
    pub version: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    /// @brief The async task control function
    /// @note This function is the only plumber API can be called from the async processing thread.
    /// And we actually have the limit for this function is we should call this function with task context,
    /// otherwise we should provide the task_handle (The example for this case is the ASYNC_CNTL_OPCODE_NOTIFY_WAIT,
    /// which we may not call the function from the thread working on the async task. In this case, we just extract
    /// the async context from the handle
    /// @todo implement this
    /// @return status code
    pub async_cntl: ::std::option::Option<
        unsafe extern "C" fn(
            async_handle: *mut runtime_api_async_handle_t,
            opcode: u32,
            ap: *mut __va_list_tag,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_address_table_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_address_table_t>(),
        112usize,
        concat!("Size of: ", stringify!(runtime_api_address_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_address_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(runtime_api_address_table_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).define as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(define)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).set_type_hook as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(set_type_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).read as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).write as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).write_scope_token as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(write_scope_token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).log_write as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(log_write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).trap as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(trap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_address_table_t>())).eof as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).cntl as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(cntl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).get_module_func as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(get_module_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).mod_open as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(mod_open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).mod_cntl_prefix as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(mod_cntl_prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).version as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).async_cntl as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(async_cntl)
        )
    );
}
/// @brief the data structure used to define a servlet
/// @note  Instead of checking if the callback fuction is defined to determine if this is an async task. We relies on the
/// return value of the init function. This is because for the language support servlet, we can not tell if it's a
/// async servlet or not during the compile time. The only way for us to kown this is get the servlet fully initialized<br/>
/// If the init function returns RUNTIME_API_INIT_RESULT_SYNC and exec function has been defined, all the async_* function
/// won't be used any mopre. This case indicates we have a sync servlet. <br/>
/// If the init function returns RUNTIME_API_INIT_RESULT_ASYNC, asyc_init must be defined
/// This case indicates we have an async servlet <br/>
/// The async_exec and async_cleanup function is not necessarily to be defined. Because for some case, we
/// actually can have a task initialize a async IO form the async_init and set the async task mode to the wait mode
/// Then we can have an undefined async_exec function, which means we don't need to do anything other than initializing
/// the IO. <br/>
/// If the exec function is not defined and init returns RUNTIME_API_INIT_RESULT_SYNC, this indicates we have an sync servlet
/// with an empty exec function. This is useful when we only have a shadow output for the servlet, for example, dataflow/dup.
/// @todo  When a servlet is loaded we should
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_servlet_def_t {
    /// < the size of the additional data for this servlet
    pub size: usize,
    /// < the description of this servlet
    pub desc: *const ::std::os::raw::c_char,
    /// < the required API version for this servlet, currently is 0
    pub version: u32,
    /// @brief The function that will be called by the initialize task
    /// @param argc the argument count
    /// @param argv the value list of arguments
    /// @param data the servlet local data that needs to be intialized
    /// @return The servlet property flags, or error code
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            argc: u32,
            argv: *const *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief the function that will be called by the execution task
    /// @param data the servlet local data
    /// @return status code
    pub exec: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief the function that will be called by the finalization task
    /// @param data the local data that need to be handled by the servlet
    /// @return status code
    pub unload: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// < The async buffer size
    pub async_buf_size: u32,
    /// @brief The initialization stage of the async task
    /// @param task This is the handle we used to pass to the async_cntl funciton
    /// @param data The servlet local context
    /// @param async_buf The buffer we are going to carry to the async_exec
    /// @note For the async_exec function, we don't allow the servlet access any servlet context,
    /// because this breaks the thread convention of the worker thread.
    /// This make the async task has to copy all the required data to the async buf, which is
    /// complete different memory, and this memory will be the only data the async_exec function
    /// can access
    /// @return status code
    pub async_setup: ::std::option::Option<
        unsafe extern "C" fn(
            task: *mut runtime_api_async_handle_t,
            async_buf: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief Execute the initialized async task, the only input of the async buf is the async buf
    /// In this function, all the API calls are disallowed.
    /// @param async_buf The async data buffer
    /// @param task This is the handle we used to pass to the async_cntl funciton
    /// @return status code
    pub async_exec: ::std::option::Option<
        unsafe extern "C" fn(
            task: *mut runtime_api_async_handle_t,
            async_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief Clean the used async data
    /// @param data The servlet local context data
    /// @param task_handle This is the handle we used to pass to the async_cntl funciton
    /// @return status code
    pub async_cleanup: ::std::option::Option<
        unsafe extern "C" fn(
            task: *mut runtime_api_async_handle_t,
            async_data: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_servlet_def_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_servlet_def_t>(),
        80usize,
        concat!("Size of: ", stringify!(runtime_api_servlet_def_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_servlet_def_t>(),
        8usize,
        concat!("Alignment of ", stringify!(runtime_api_servlet_def_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).version as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).exec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(exec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).unload as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_buf_size as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_setup as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_setup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_exec as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_exec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_cleanup as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_cleanup)
        )
    );
}
/// @brief the metadata that is defined in the servlet and used by the framework
pub type servlet_def_t = runtime_api_servlet_def_t;
/// @brief the section pipe desciptor
pub type pipe_t = runtime_api_pipe_t;
/// @brief the function address table that provide by the framework
pub type address_table_t = runtime_api_address_table_t;
/// @brief the type for the pipe flags
pub type pipe_flags_t = runtime_api_pipe_flags_t;
/// @brief represent a RSL token
pub type scope_token_t = runtime_api_scope_token_t;
/// @brief the type for the scope entity
pub type scope_entity_t = runtime_api_scope_entity_t;
/// @brief the type for the token data request
pub type scope_token_data_req_t = runtime_api_scope_token_data_request_t;
/// @brief the type for the type inference callback function
pub type pipe_type_callback_t = runtime_api_pipe_type_callback_t;
/// @brief the type for the async task handle
pub type async_handle_t = runtime_api_async_handle_t;
/// @brief The type used to describe the scope stream ready event
pub type scope_ready_event_t = runtime_api_scope_ready_event_t;
/// Use this level when something would stop the program
pub const FATAL: _bindgen_ty_2 = 0;
/// Error level, the routine can not continue
pub const ERROR: _bindgen_ty_2 = 1;
/// Warning level, the routine can continue, but something may be wrong
pub const WARNING: _bindgen_ty_2 = 2;
/// Notice level, there's no error, but something you should notice
pub const NOTICE: _bindgen_ty_2 = 3;
/// Info level, provide some information
pub const INFO: _bindgen_ty_2 = 4;
/// Trace level, trace the program routine and behviours
pub const TRACE: _bindgen_ty_2 = 5;
/// Debug level, detail information used for debugging
pub const DEBUG: _bindgen_ty_2 = 6;
/// @brief log levels
pub type _bindgen_ty_2 = u32;
pub type useconds_t = __useconds_t;
pub type pid_t = __pid_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__environ"]
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: _bindgen_ty_3 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_3 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_3 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_3 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_3 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_3 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_3 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_3 = 7;
pub const _PC_VDISABLE: _bindgen_ty_3 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_3 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_3 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_3 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_3 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_3 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_3 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_3 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_3 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_3 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_3 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_3 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_3 = 20;
pub type _bindgen_ty_3 = u32;
pub const _SC_ARG_MAX: _bindgen_ty_4 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_4 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_4 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_4 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_4 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_4 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_4 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_4 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_4 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_4 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_4 = 10;
pub const _SC_TIMERS: _bindgen_ty_4 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_4 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_4 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_4 = 14;
pub const _SC_FSYNC: _bindgen_ty_4 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_4 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_4 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_4 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_4 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_4 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_4 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_4 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_4 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_4 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_4 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_4 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_4 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_4 = 28;
pub const _SC_VERSION: _bindgen_ty_4 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_4 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_4 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_4 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_4 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_4 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_4 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_4 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_4 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_4 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_4 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_4 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_4 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_4 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_4 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_4 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_4 = 45;
pub const _SC_2_VERSION: _bindgen_ty_4 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_4 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_4 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_4 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_4 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_4 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_4 = 52;
pub const _SC_PII: _bindgen_ty_4 = 53;
pub const _SC_PII_XTI: _bindgen_ty_4 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_4 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_4 = 56;
pub const _SC_PII_OSI: _bindgen_ty_4 = 57;
pub const _SC_POLL: _bindgen_ty_4 = 58;
pub const _SC_SELECT: _bindgen_ty_4 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_4 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_4 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_4 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_4 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_4 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_4 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_4 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_4 = 66;
pub const _SC_THREADS: _bindgen_ty_4 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_4 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_4 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_4 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_4 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_4 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_4 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_4 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_4 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_4 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_4 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_4 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_4 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_4 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_4 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_4 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_4 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_4 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_4 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_4 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_4 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_4 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_4 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_4 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_4 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_4 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_4 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_4 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_4 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_4 = 96;
pub const _SC_2_UPE: _bindgen_ty_4 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_4 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_4 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_4 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_4 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_4 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_4 = 103;
pub const _SC_INT_MAX: _bindgen_ty_4 = 104;
pub const _SC_INT_MIN: _bindgen_ty_4 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_4 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_4 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_4 = 108;
pub const _SC_NZERO: _bindgen_ty_4 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_4 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_4 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_4 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_4 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_4 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_4 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_4 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_4 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_4 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_4 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_4 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_4 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_4 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_4 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_4 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_4 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_4 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_4 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_4 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_4 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_4 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_4 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_4 = 132;
pub const _SC_BARRIERS: _bindgen_ty_4 = 133;
pub const _SC_BASE: _bindgen_ty_4 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_4 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_4 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_4 = 137;
pub const _SC_CPUTIME: _bindgen_ty_4 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_4 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_4 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_4 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_4 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_4 = 143;
pub const _SC_FIFO: _bindgen_ty_4 = 144;
pub const _SC_PIPE: _bindgen_ty_4 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_4 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_4 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_4 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_4 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_4 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_4 = 151;
pub const _SC_NETWORKING: _bindgen_ty_4 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_4 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_4 = 154;
pub const _SC_REGEXP: _bindgen_ty_4 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_4 = 156;
pub const _SC_SHELL: _bindgen_ty_4 = 157;
pub const _SC_SIGNALS: _bindgen_ty_4 = 158;
pub const _SC_SPAWN: _bindgen_ty_4 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_4 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_4 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_4 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_4 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_4 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_4 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_4 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_4 = 167;
pub const _SC_2_PBS: _bindgen_ty_4 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_4 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_4 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_4 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_4 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_4 = 173;
pub const _SC_STREAMS: _bindgen_ty_4 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_4 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_4 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_4 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_4 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_4 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_4 = 180;
pub const _SC_TRACE: _bindgen_ty_4 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_4 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_4 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_4 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_4 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_4 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_4 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_4 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_4 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_4 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_4 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_4 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_4 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_4 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_4 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_4 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_4 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_4 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_4 = 199;
pub const _SC_IPV6: _bindgen_ty_4 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_4 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_4 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_4 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_4 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_4 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_4 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_4 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_4 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_4 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_4 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_4 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_4 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_4 = 248;
pub type _bindgen_ty_4 = u32;
pub const _CS_PATH: _bindgen_ty_5 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_5 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_5 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_5 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_5 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_5 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_5 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_5 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_5 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_5 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_5 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_5 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_5 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_5 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_5 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_5 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_5 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_5 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_5 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_5 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_5 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_5 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_5 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_5 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_5 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_5 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_5 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_5 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_5 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_5 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_5 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_5 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_5 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_5 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_5 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_5 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_5 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_5 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_5 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_5 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_5 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_5 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_5 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_5 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_5 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_5 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_5 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_5 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_5 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_5 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_5 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_5 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_5 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_5 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_5 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_5 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_5 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_5 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_5 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_5 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_5 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_5 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_5 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_5 = 1149;
pub type _bindgen_ty_5 = u32;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct pipe_array_t {
    pub size: u32,
    pub __padding__: __IncompleteArrayField<usize>,
    pub pipes: __IncompleteArrayField<pipe_t>,
}
#[test]
fn bindgen_test_layout_pipe_array_t() {
    assert_eq!(
        ::std::mem::size_of::<pipe_array_t>(),
        8usize,
        concat!("Size of: ", stringify!(pipe_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pipe_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_array_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_array_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_array_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_array_t>())).__padding__ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_array_t),
            "::",
            stringify!(__padding__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_array_t>())).pipes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_array_t),
            "::",
            stringify!(pipes)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_size_pipe_array_t_pipes {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_size_pipe_array_t_pipes() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_size_pipe_array_t_pipes>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_size_pipe_array_t_pipes)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_size_pipe_array_t_pipes>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_size_pipe_array_t_pipes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_size_pipe_array_t_pipes>())).test as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_size_pipe_array_t_pipes),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_last_pipe_array_t_pipes {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_last_pipe_array_t_pipes() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_last_pipe_array_t_pipes>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_last_pipe_array_t_pipes)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_last_pipe_array_t_pipes>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_last_pipe_array_t_pipes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_last_pipe_array_t_pipes>())).test as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_last_pipe_array_t_pipes),
            "::",
            stringify!(test)
        )
    );
}
/// @brief The pipe intiialization param used by the batch operation
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_init_param_t {
    /// < The target variable for the pipe dsec
    pub target: *mut pipe_t,
    /// < The name of the pipe
    pub name: *const ::std::os::raw::c_char,
    /// < The flag we should use
    pub flags: pipe_flags_t,
    /// < The type we use
    pub type_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pipe_init_param_t() {
    assert_eq!(
        ::std::mem::size_of::<pipe_init_param_t>(),
        32usize,
        concat!("Size of: ", stringify!(pipe_init_param_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pipe_init_param_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_init_param_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_init_param_t>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_init_param_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_init_param_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_init_param_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_init_param_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_init_param_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pipe_init_param_t>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_init_param_t),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Init pipes in the params list
    /// @param params The param list
    /// @param count The number of pipes to initialize
    /// @return status code
    pub fn pipe_batch_init(params: *const pipe_init_param_t, count: usize)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__plumber_address_table"]
    pub static mut __plumber_address_table: *const address_table_t;
}
extern "C" {
    #[link_name = "\u{1}__servdef__"]
    pub static mut __servdef__: servlet_def_t;
}
extern "C" {
    /// @brief allocate memory from the memory pool
    /// @param size the size of the memory chunck
    /// @return the result pointer, NULL indicates error
    pub fn pstd_mempool_alloc(size: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief free used memory allocated from the memory pool
    /// @param mem the memory to free
    /// @return the status code
    pub fn pstd_mempool_free(mem: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief allocate an entire page from the memory pool
    /// @return the page allocated or NULL on error case
    pub fn pstd_mempool_page_alloc() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief deallocate the entire page which is allocated by pstd_mempool_page_alloc
    /// @param page the page to deallocate
    /// @return status code
    pub fn pstd_mempool_page_dealloc(page: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_bio_t {
    _unused: [u8; 0],
}
/// @brief the high level level bufferered pipe IO
pub type pstd_bio_t = _pstd_bio_t;
extern "C" {
    /// @brief create new BIO object
    /// @param pipe the pipe used by this BIO object
    /// @note the BIO object uses the auto memory allocator, so free is optional
    /// @return the newly create pipe
    pub fn pstd_bio_new(pipe: pipe_t) -> *mut pstd_bio_t;
}
extern "C" {
    /// @brief flush a BIO buffer
    /// @param pstd_bio the target pstd_bio object
    /// @return status code
    pub fn pstd_bio_flush(pstd_bio: *mut pstd_bio_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief free a pstd_bio object and flush unwritten buffer
    /// @param pstd_bio the pstd_bio object
    /// @return status code
    pub fn pstd_bio_free(pstd_bio: *mut pstd_bio_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief get the pipe that this BIO object operates
    /// @param pstd_bio the target BIO
    /// @return the result pipe or status code
    pub fn pstd_bio_pipe(pstd_bio: *mut pstd_bio_t) -> pipe_t;
}
extern "C" {
    /// @brief set the BIO buffer size
    /// @param pstd_bio the target BIO object
    /// @param size the size of the buffer
    /// @return status code
    pub fn pstd_bio_set_buf_size(pstd_bio: *mut pstd_bio_t, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief read structs from the BIO object
    /// @param pstd_bio the target pstd_bio object
    /// @param ptr the target point
    /// @param size the size of the buffer
    /// @return the size of bytes has been read from the BIO object, or error code
    pub fn pstd_bio_read(
        pstd_bio: *mut pstd_bio_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// @brief get a single char from the bufferred IO object
    /// @param pstd_bio the target BIO object
    /// @param ch the result char
    /// @return number of char returned, or error code
    pub fn pstd_bio_getc(
        pstd_bio: *mut pstd_bio_t,
        ch: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief check if the BIO object has no more data to read
    /// @param pstd_bio the target BIO object
    /// @return the result or status code
    pub fn pstd_bio_eof(pstd_bio: *mut pstd_bio_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief write structs to the BIO object
    /// @param pstd_bio the target pstd_bio object
    /// @param ptr the data to write
    /// @param size the size of the buffer
    /// @return the number of bytes has been actually written
    pub fn pstd_bio_write(
        pstd_bio: *mut pstd_bio_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// @brief write the RLS content to the pipe
    /// @param pstd_bio the target pstd_bio object
    /// @param token the token to write
    /// @note this function will make sure all the bytes for the token be written
    /// @return status code
    pub fn pstd_bio_write_scope_token(
        pstd_bio: *mut pstd_bio_t,
        token: scope_token_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief formated print to BIO
    /// @param pstd_bio the target pstd_bio
    /// @param fmt the formating string
    /// @return number of bytes has written
    pub fn pstd_bio_printf(
        pstd_bio: *mut pstd_bio_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> usize;
}
extern "C" {
    /// @brief similar to pstd_bio_printf, the differents is this function accepts va_list
    /// @param pstd_bio The target BIO
    /// @param fmt The formatting string
    /// @param ap The additional parameters
    /// @return number of bytes has been written
    pub fn pstd_bio_vprintf(
        pstd_bio: *mut pstd_bio_t,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> usize;
}
extern "C" {
    /// @brief write a string to a BIO object
    /// @param pstd_bio the target BIO
    /// @param str the line to write
    /// @return the number of bytes has written
    pub fn pstd_bio_puts(pstd_bio: *mut pstd_bio_t, str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    /// @brief write a signle char to a BIO object
    /// @param pstd_bio the target BIO object
    /// @param ch the char to write
    /// @return the number of bytes has written
    pub fn pstd_bio_putc(
        pstd_bio: *mut pstd_bio_t,
        ch: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
/// @brief the previous definition of the pstd_option_t
pub type pstd_option_t = _pstd_option_t;
pub const pstd_option_param_type_t_PSTD_OPTION_TYPE_INT: pstd_option_param_type_t = 0;
pub const pstd_option_param_type_t_PSTD_OPTION_TYPE_DOUBLE: pstd_option_param_type_t = 1;
pub const pstd_option_param_type_t_PSTD_OPTION_STRING: pstd_option_param_type_t = 2;
/// @brief the option param type
pub type pstd_option_param_type_t = u32;
/// @brief describe an option param
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pstd_option_param_t {
    /// < the type of this param
    pub type_: pstd_option_param_type_t,
    pub __bindgen_anon_1: pstd_option_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pstd_option_param_t__bindgen_ty_1 {
    /// < the integer value
    pub intval: i64,
    /// < the double value
    pub doubleval: f64,
    /// < the string value
    pub strval: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pstd_option_param_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pstd_option_param_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pstd_option_param_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_option_param_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pstd_option_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_option_param_t__bindgen_ty_1>())).intval as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_param_t__bindgen_ty_1),
            "::",
            stringify!(intval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_option_param_t__bindgen_ty_1>())).doubleval as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_param_t__bindgen_ty_1),
            "::",
            stringify!(doubleval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_option_param_t__bindgen_ty_1>())).strval as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_param_t__bindgen_ty_1),
            "::",
            stringify!(strval)
        )
    );
}
#[test]
fn bindgen_test_layout_pstd_option_param_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_option_param_t>(),
        16usize,
        concat!("Size of: ", stringify!(pstd_option_param_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_option_param_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstd_option_param_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_option_param_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_param_t),
            "::",
            stringify!(type_)
        )
    );
}
/// @brief The command line option data when we are parsing a command line option
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pstd_option_data_t {
    /// < The list of all the options
    pub option_array: *const pstd_option_t,
    /// < The current option we are talking about
    pub current_option: *const pstd_option_t,
    /// < The array that contains the parameter for this option
    pub param_array: *mut pstd_option_param_t,
    /// < The size of the option array
    pub option_array_size: u32,
    /// < The size of the parameter array
    pub param_array_size: u32,
    /// < The additional callback function data
    pub cb_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pstd_option_data_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_option_data_t>(),
        40usize,
        concat!("Size of: ", stringify!(pstd_option_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_option_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstd_option_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_option_data_t>())).option_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_data_t),
            "::",
            stringify!(option_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_option_data_t>())).current_option as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_data_t),
            "::",
            stringify!(current_option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_option_data_t>())).param_array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_data_t),
            "::",
            stringify!(param_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_option_data_t>())).option_array_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_data_t),
            "::",
            stringify!(option_array_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_option_data_t>())).param_array_size as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_data_t),
            "::",
            stringify!(param_array_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_option_data_t>())).cb_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_option_data_t),
            "::",
            stringify!(cb_data)
        )
    );
}
/// @brief the callback function used to handle the option
/// @param data the option data
/// @return status code
pub type pstd_option_handler_t =
    ::std::option::Option<unsafe extern "C" fn(data: pstd_option_data_t) -> ::std::os::raw::c_int>;
/// @brief describe a single option
/// @note the pattern should be written like "III" ==> expecting there are three interger <br/>
/// For optional param use * as prefix "?III" ==> an optional param with 3 integer<br/>
/// I = integer <br/>
/// D = double <br/>
/// S = string <br/>
/// All the param should be seperated with  &lt;space&gt; or &lt;tab&gt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_option_t {
    /// < the long option
    pub long_opt: *const ::std::os::raw::c_char,
    /// < the short option
    pub short_opt: ::std::os::raw::c_char,
    /// < the value pattern
    pub pattern: *const ::std::os::raw::c_char,
    /// < the option description
    pub description: *const ::std::os::raw::c_char,
    /// < the handler of this option
    pub handler: pstd_option_handler_t,
    /// < the additional argument passed to the handler
    pub args: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__pstd_option_t() {
    assert_eq!(
        ::std::mem::size_of::<_pstd_option_t>(),
        48usize,
        concat!("Size of: ", stringify!(_pstd_option_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_pstd_option_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_pstd_option_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pstd_option_t>())).long_opt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pstd_option_t),
            "::",
            stringify!(long_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pstd_option_t>())).short_opt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pstd_option_t),
            "::",
            stringify!(short_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pstd_option_t>())).pattern as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pstd_option_t),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pstd_option_t>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pstd_option_t),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pstd_option_t>())).handler as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_pstd_option_t),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pstd_option_t>())).args as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_pstd_option_t),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_option_parser_t {
    _unused: [u8; 0],
}
/// @brief the option parser object
pub type pstd_option_parser_t = _pstd_option_parser_t;
extern "C" {
    /// @brief parse the command line options using the given parser
    /// @param options the parser used to parse the command line
    /// @param n the number of valid options
    /// @param argc the number of arguments
    /// @param argv the argument array
    /// @param userdata the user defined data
    /// @return the index of first argument that has not been parsed by the parser, or error code
    pub fn pstd_option_parse(
        options: *const pstd_option_t,
        n: u32,
        argc: u32,
        argv: *const *const ::std::os::raw::c_char,
        userdata: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    /// @brief the standard option handler that print the help message
    /// @param data The option data
    /// @return status code
    pub fn pstd_option_handler_print_help(data: pstd_option_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief sort the options in alphabetical order
    /// @param options the options array
    /// @param n the size of the array
    /// @return status code
    pub fn pstd_option_sort(options: *mut pstd_option_t, n: u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_thread_local_t {
    _unused: [u8; 0],
}
/// @brief a thread local object
pub type pstd_thread_local_t = _pstd_thread_local_t;
/// @brief the allocator function used to allocate a new pointer to a new thread
/// @param tid the thread id
/// @param data the additional data passed to the allocator
/// @return the newly allocated memory NULL on error case
pub type pstd_thread_local_allocator_t = ::std::option::Option<
    unsafe extern "C" fn(tid: u32, data: *const ::std::os::raw::c_void)
        -> *mut ::std::os::raw::c_void,
>;
/// @brief the deallocator function used to free a pointer which allocated by the thread local allocator
/// @param mem the memory to free
/// @param data the additional data passed to the dealloctor
/// @return status code
pub type pstd_thread_local_dealloctor_t = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void, data: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    /// @brief create a new thread local object
    /// @param alloc the allocator
    /// @param dealloc the dealloctor
    /// @param data the additional data passed to the allocator and dealloctor
    /// @return the newly created thread local object or NULL on error
    pub fn pstd_thread_local_new(
        alloc: pstd_thread_local_allocator_t,
        dealloc: pstd_thread_local_dealloctor_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut pstd_thread_local_t;
}
extern "C" {
    /// @brief get the pointer which is allocated for current thread from the thread local object
    /// @param local the thread local
    /// @return the pointer for current thread or NULL on error
    pub fn pstd_thread_local_get(local: *mut pstd_thread_local_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief dispose a used thread local
    /// @param local the thread local
    /// @return status code
    pub fn pstd_thread_local_free(local: *mut pstd_thread_local_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_scope_stream_t {
    _unused: [u8; 0],
}
/// @brief The dummy type that is for compiler knowing we are talking about the RLS stream
pub type pstd_scope_stream_t = _pstd_scope_stream_t;
extern "C" {
    /// @brief add a new pointer to the scope managed pointer infrastructure
    /// @details Once this function gets called, the memory will be assigned with an integer token, then the servlet
    /// will be able to write the token to pipe, and the downstream servlet will be able to get the pointer
    /// by the token in the pipe. <br/>
    /// The memory will be automatically disposed after the request is done. <br/>
    /// This function will take the ownership of the pointer mem, so do not dispose the pointer once the function
    /// returns successfully
    /// @param entity the scope entity to add
    /// @note  the entity parameter do not pass the ownership of the entity, however, entity->data will be taken if
    /// the function retuens successfully
    /// @return  the token for the pointer or error code
    pub fn pstd_scope_add(entity: *const scope_entity_t) -> scope_token_t;
}
extern "C" {
    /// @brief Copy the existing token
    /// @details this function will make a copy of the existing memory by calling its copy callback, and then assign it with
    /// a new scope token. This should be used if the shared memory needs to be changed, because we want to make sure
    /// that the result shouldn't be related to the servlet execution order. However, if there are two servlets needs
    /// to change the same pointer, it's possible that the previous one will be overridden by the latter one. So we
    /// need to make sure each of the servlet make their own copy before the change. <br/>
    /// And this guareentee the reuslt is not related to the execution order
    /// @param  token the token to copy
    /// @param  resbuf the result buffer used to return the pointer after the copy
    /// @return the token for the copied pointer or error code
    pub fn pstd_scope_copy(
        token: scope_token_t,
        resbuf: *mut *mut ::std::os::raw::c_void,
    ) -> scope_token_t;
}
extern "C" {
    /// @brief get the underlying pointer from the scope token
    /// @param token the scope token
    /// @return the pointer, NULL on error case
    pub fn pstd_scope_get(token: scope_token_t) -> *const ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Open a RLS scope as a DRA stream
    /// @param token The RLS token to open
    /// @return The newly create stream object
    pub fn pstd_scope_stream_open(token: scope_token_t) -> *mut pstd_scope_stream_t;
}
extern "C" {
    /// @brief Read bytes from the RLS stream
    /// @param stream The stream to read
    /// @param buf The buffer
    /// @param size The size of buffer
    /// @return number of bytes has been read
    pub fn pstd_scope_stream_read(
        stream: *mut pstd_scope_stream_t,
        buf: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// @brief Check if the stream has reached the end
    /// @param stream The stream to check
    /// @param if the stream has reached end or error code
    pub fn pstd_scope_stream_eof(stream: *const pstd_scope_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Close a stream that is no longer used
    /// @param stream The stream to close
    /// @param status code
    pub fn pstd_scope_stream_close(stream: *mut pstd_scope_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Get the ready event
    /// @param stream The stream to query
    /// @param buf The buffer for the result event
    /// @return number of event has been returned
    pub fn pstd_scope_stream_ready_event(
        stream: *mut pstd_scope_stream_t,
        buf: *mut scope_ready_event_t,
    ) -> ::std::os::raw::c_int;
}
/// @brief The object that is managed by reference counter
/// @note Once a RLS object entity is committed in this way, the object will be tracked
/// by the reference counter, once the reference counter becomes 0, the object will
/// be disposed autoamtically. After that the scope token will be invalidate.
/// This is useful if we need some RLS that is used as the temp buffer.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pstd_scope_gc_obj_t {
    /// < The actual data object
    pub obj: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pstd_scope_gc_obj_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_scope_gc_obj_t>(),
        8usize,
        concat!("Size of: ", stringify!(pstd_scope_gc_obj_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_scope_gc_obj_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstd_scope_gc_obj_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_scope_gc_obj_t>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_scope_gc_obj_t),
            "::",
            stringify!(obj)
        )
    );
}
extern "C" {
    /// @brief Add a GC object to scope
    /// @param tid The type Id
    /// @param entity the scope entity object
    /// @param free   the dispose function
    /// @param obj    The buffer used to return object
    /// @return The token or error code
    pub fn pstd_scope_gc_add(
        entity: *const scope_entity_t,
        obj: *mut *mut pstd_scope_gc_obj_t,
    ) -> scope_token_t;
}
extern "C" {
    /// @brief Acquire the scope object from the sccope
    /// @note If the RLS object is committed by pstd_scope_gc_add, this function
    /// should be used to retrive the scope object.
    /// @param token The target token
    /// @return The gc object
    pub fn pstd_scope_gc_get(token: scope_token_t) -> *mut pstd_scope_gc_obj_t;
}
extern "C" {
    /// @brief Increase the reference counter
    /// @param obj The gc object to incref
    /// @return status code
    pub fn pstd_scope_gc_incref(obj: *mut pstd_scope_gc_obj_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Decref the reference counter
    /// @param obj The gc object to decref
    /// @return status code
    pub fn pstd_scope_gc_decref(obj: *mut pstd_scope_gc_obj_t) -> ::std::os::raw::c_int;
}
/// @brief the callback function which will be called when libplumber finalize
/// @note the callback also responsible for disposing the data pointer if it requires to dispose
/// @param data the additional data for this callback function
/// @return nothing
pub type pstd_onexit_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
extern "C" {
    /// @brief register the callback function that will be called when the libplumber exits, this require pssm loaded
    /// @details if there are multiple callback is registered in the system, the callback function will be called the
    /// last registered function first. (The callback list is a stack)
    /// @param callback the callback function
    /// @param data the optional addtional data
    /// @note the callback may also responsible to dispose the data pointer if the data pointer requires a free <br/>
    /// If the function returns a failure, the data pointer may need to be disposed by the caller because the ownership
    /// isn't taken unless it returns a success
    /// @return status code
    pub fn pstd_onexit(
        callback: pstd_onexit_callback_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_fcache_file_t {
    _unused: [u8; 0],
}
/// @brief represent a reference to the entry in the file cache
pub type pstd_fcache_file_t = _pstd_fcache_file_t;
extern "C" {
    /// @brief open a given file from the file cache, if the cache hits, we return the reference to cache entry.
    /// otherwise we will allocate a new cache entry and return a reference to the entry that entry
    /// @param filename the file name that we want to access on the disk
    /// @return status code
    pub fn pstd_fcache_open(filename: *const ::std::os::raw::c_char) -> *mut pstd_fcache_file_t;
}
extern "C" {
    /// @brief dispose a used file cache reference object
    /// @param file reference to the file cache entry
    /// @return status code
    pub fn pstd_fcache_close(file: *mut pstd_fcache_file_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief read bytes from the file cache reference
    /// @param file the reference to the cached file
    /// @param buf the data buffer used to return the read result
    /// @param bufsize the size of the buffer
    /// @return the number of bytes has been read to buffer or error code
    pub fn pstd_fcache_read(
        file: *mut pstd_fcache_file_t,
        buf: *mut ::std::os::raw::c_void,
        bufsize: usize,
    ) -> usize;
}
extern "C" {
    /// @brief get the size of the reference to the cached file
    /// @param file the file we want to access
    /// @return the size of the cached file or error code
    pub fn pstd_fcache_size(file: *const pstd_fcache_file_t) -> usize;
}
extern "C" {
    /// @brief check if the reference to cached file has reached the end of the file
    /// @param file the reference to the cahced file entry to access
    /// @return status code
    pub fn pstd_fcache_eof(file: *const pstd_fcache_file_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief check if the filename is in the cache
    /// @param filename the file name to check
    /// @return check result or error code
    pub fn pstd_fcache_is_in_cache(
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief access the file metadata through the cache system, if the file information is prevoiusly cached
    /// just directly return and do not call the disk IO function
    /// @param filename the filename to access
    /// @param buf the result buffer
    /// @return status code
    pub fn pstd_fcache_stat(
        filename: *const ::std::os::raw::c_char,
        buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Jump to the given location
    /// @param file The reference to the cached file
    /// @param offset The offset
    /// @return the new offset in the file
    pub fn pstd_fcache_seek(file: *mut pstd_fcache_file_t, offset: usize) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_dfa_t {
    _unused: [u8; 0],
}
/// @brief The previous definition for a DFA object
pub type pstd_dfa_t = _pstd_dfa_t;
/// @brief The parameter will be passed to the processor
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pstd_dfa_process_param_t {
    /// < The state variable
    pub state: *mut ::std::os::raw::c_void,
    /// < Current DFA object
    pub dfa: *mut pstd_dfa_t,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pstd_dfa_process_param_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_dfa_process_param_t>(),
        24usize,
        concat!("Size of: ", stringify!(pstd_dfa_process_param_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_dfa_process_param_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstd_dfa_process_param_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_process_param_t>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_process_param_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_process_param_t>())).dfa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_process_param_t),
            "::",
            stringify!(dfa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_process_param_t>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_process_param_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pstd_dfa_ops_t {
    /// @brief Create a new DFA state
    /// @return The state has been created or NULL on error
    pub create_state: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    /// @brief Dispose a used DFA state
    /// @param state the state to dispose
    /// @return status code
    pub dispose_state: ::std::option::Option<
        unsafe extern "C" fn(state: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief Process the next block of data
    /// @param ch the next charecter in the data stream
    /// @param param parameter
    /// return status code
    pub process: ::std::option::Option<
        unsafe extern "C" fn(ch: ::std::os::raw::c_char, param: pstd_dfa_process_param_t)
            -> ::std::os::raw::c_int,
    >,
    /// @brief Called when the DFA is finished
    /// @param param the param
    /// @return status code
    pub post_process: ::std::option::Option<
        unsafe extern "C" fn(param: pstd_dfa_process_param_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_pstd_dfa_ops_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_dfa_ops_t>(),
        32usize,
        concat!("Size of: ", stringify!(pstd_dfa_ops_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_dfa_ops_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstd_dfa_ops_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_ops_t>())).create_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_ops_t),
            "::",
            stringify!(create_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_ops_t>())).dispose_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_ops_t),
            "::",
            stringify!(dispose_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_ops_t>())).process as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_ops_t),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_dfa_ops_t>())).post_process as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_dfa_ops_t),
            "::",
            stringify!(post_process)
        )
    );
}
/// < Something wrong with the DFA
pub const pstd_dfa_state_t_PSTD_DFA_ERROR: pstd_dfa_state_t = -1;
/// < The DFA is currently stopped normally
pub const pstd_dfa_state_t_PSTD_DFA_FINISHED: pstd_dfa_state_t = 0;
/// < The DFA has exhuasted the pipe data but still not reach the finished state
pub const pstd_dfa_state_t_PSTD_DFA_EXHUASTED: pstd_dfa_state_t = 1;
/// < The DFA is currently waiting for more data, in this case the servlet shouldn't touch any pipe and return
pub const pstd_dfa_state_t_PSTD_DFA_WAITING: pstd_dfa_state_t = 2;
/// @brief represent the state of the DFA
pub type pstd_dfa_state_t = i32;
extern "C" {
    /// @brief run DFA on the given pipe
    /// @param input the input pipe
    /// @param ops the operation callbacks
    /// @param data additional data pass to ops functions
    /// @return status code
    pub fn pstd_dfa_run(
        input: pipe_t,
        ops: pstd_dfa_ops_t,
        data: *mut ::std::os::raw::c_void,
    ) -> pstd_dfa_state_t;
}
extern "C" {
    /// @brief Set the DFA to the Finished state
    /// @param dfa the DFA object to set
    /// @return status code
    /// @note this function must be called in the DFA callbacks
    pub fn pstd_dfa_done(dfa: *mut pstd_dfa_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_type_model_t {
    _unused: [u8; 0],
}
/// @brief The servlet context object used to tack the type information for all the pipe
/// for one servlet intance
pub type pstd_type_model_t = _pstd_type_model_t;
/// @brief The reference to an accessor in the type model
pub type pstd_type_accessor_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pstd_type_instance_t {
    _unused: [u8; 0],
}
/// @brief Represent a instance of the servlet type context
pub type pstd_type_instance_t = _pstd_type_instance_t;
/// @brief Represent the information to access a field
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pstd_type_field_t {
    /// < The offeset of this field
    pub offset: u32,
    /// < The size of memory region for this field
    pub size: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pstd_type_field_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_type_field_t>(),
        12usize,
        concat!("Size of: ", stringify!(pstd_type_field_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_type_field_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pstd_type_field_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_type_field_t>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_field_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstd_type_field_t>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_field_t),
            "::",
            stringify!(size)
        )
    );
}
impl pstd_type_field_t {
    #[inline]
    pub fn is_numeric(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_numeric(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_signed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_signed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_float(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_float(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_token(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_token(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_primitive_token(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_primitive_token(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_numeric: u32,
        is_signed: u32,
        is_float: u32,
        is_token: u32,
        is_primitive_token: u32,
        is_compound: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_numeric: u32 = unsafe { ::std::mem::transmute(is_numeric) };
            is_numeric as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_signed: u32 = unsafe { ::std::mem::transmute(is_signed) };
            is_signed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_float: u32 = unsafe { ::std::mem::transmute(is_float) };
            is_float as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_token: u32 = unsafe { ::std::mem::transmute(is_token) };
            is_token as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_primitive_token: u32 = unsafe { ::std::mem::transmute(is_primitive_token) };
            is_primitive_token as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_compound: u32 = unsafe { ::std::mem::transmute(is_compound) };
            is_compound as u64
        });
        __bindgen_bitfield_unit
    }
}
/// @brief The function used as the type assertion
/// @param pipe The pipe descriptor
/// @param type The type name
/// @param data The additional data to this assertion
/// @return status code
pub type pstd_type_assertion_t = ::std::option::Option<
    unsafe extern "C" fn(
        pipe: pipe_t,
        type_: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// @brief Create a new pipe type model object
    /// @return the newly create pipe, NULL on error  case
    pub fn pstd_type_model_new() -> *mut pstd_type_model_t;
}
extern "C" {
    /// @brief Dispose an used type model
    /// @param model The type model to dispose
    /// @return status code
    pub fn pstd_type_model_free(model: *mut pstd_type_model_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Register an accessor for the given pipe and field expression
    /// @param model The typeinfo context
    /// @param pipe The pipe descriptor
    /// @param field_expr The field expression
    /// @return Status code
    pub fn pstd_type_model_get_accessor(
        model: *mut pstd_type_model_t,
        pipe: pipe_t,
        field_expr: *const ::std::os::raw::c_char,
    ) -> pstd_type_accessor_t;
}
extern "C" {
    /// @brief Get the field information about a field.
    /// @details This is similar to pstd_type_model_get_accessor, but instead of returning an accessor
    /// it will set the type information to the given memory location. <br/>
    /// This is not useful when we want to handle the actual pipe type, for example "plumber/std/request_local/String", etc.
    /// However, this function is important for operating inner types of a ecapsulated type.
    /// Since a ecapsulated type, for example "plumber/std/request_local/Array SomeType"
    /// If we want to access a field in SomeType, the accessor won't work.
    /// The semantics of encapsulated type means the data from the pipe contains enough information to reconstruct a instance
    /// of inner type. Which means, the inner type might be in some other memory buffer the servlet allocates.
    /// Thus, we need type information instead of accessor to access the in memory data field, rather than from the pipe directly. <br/>
    /// Another difference of this function is it allows the access of the inner type. For example, we want to access SomeType.some_field
    /// from the array, we need to use "*some_field" for this purpose, the first star indicates we are asking about the inner type
    /// @param   model The type model to query
    /// @param   pipe  The pipe descriptor
    /// @param   field_expr The field epxression we want to query
    /// @param   buf The type buffer
    /// @return status code
    pub fn pstd_type_model_get_field_info(
        model: *mut pstd_type_model_t,
        pipe: pipe_t,
        field_expr: *const ::std::os::raw::c_char,
        buf: *mut pstd_type_field_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Add a type assertion to the given pipe
    /// @note  This function allows user add a type assertion, which checks if the type is expected
    /// @param model     The type model
    /// @param pipe      The target pipe descriptor
    /// @param assertion The assertion function
    /// @param data      The additional data we want to pass
    /// @return status code
    pub fn pstd_type_model_assert(
        model: *mut pstd_type_model_t,
        pipe: pipe_t,
        assertion: pstd_type_assertion_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Add a directive indicates the to pipe contains a copy of from pipe when each time the servlet
    /// gets exectuted
    /// @details This function is typically useful when we needs to performe some modification to the typed header
    /// and build an output based on this. <br/>
    /// This requires the type of from pipe is actually a sub-type of to pipe.
    /// @param from The from pipe
    /// @param to   The to pipe
    /// @return status code
    pub fn pstd_type_model_copy_pipe_data(
        model: *mut pstd_type_model_t,
        from: pipe_t,
        to: pipe_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Comput the size of the type context instance for the given type model
    /// @param model The input type model
    /// @return The size or error code
    pub fn pstd_type_instance_size(model: *const pstd_type_model_t) -> usize;
}
extern "C" {
    /// @brief Create a new type instance object
    /// @note  For each typed header IO, the servlet should create a type instance
    /// @param model The type model we create the instance for
    /// @param mem do not allocate memory, use the given pointer
    /// @return The newly created type instance, NULL on error case
    pub fn pstd_type_instance_new(
        model: *const pstd_type_model_t,
        mem: *mut ::std::os::raw::c_void,
    ) -> *mut pstd_type_instance_t;
}
extern "C" {
    /// @brief Dispose a used type instance
    /// @param inst The type instance to dispose
    /// @return status code
    pub fn pstd_type_instance_free(inst: *mut pstd_type_instance_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Read data from the given type accessor under the type context, this *must* be called inside exec task
    /// @param inst     The type context isntance
    /// @param accessor The accessor for the data we interseted in
    /// @param buf      The buffer used to carry the result
    /// @param bufsize  The size of the buffer
    /// @return The number of bytes has been read to the buffer
    pub fn pstd_type_instance_read(
        inst: *mut pstd_type_instance_t,
        accessor: pstd_type_accessor_t,
        buf: *mut ::std::os::raw::c_void,
        bufsize: usize,
    ) -> usize;
}
extern "C" {
    /// @brief Write data to the pipe header, this *must* be called inside exec task
    /// @param inst     The type context instance
    /// @param accessor The accessor for the data we are interested in
    /// @param buf      The data buffer we want to write
    /// @param bufsize  The size of the buffer
    /// @return Status code
    /// @note Because this function will guarentee all the byte will be written to the buffer, so
    /// we do not provide the return value of how many bytes has been written. <br/>
    /// If the buffer size is larger than the size of the memory regoin the accessor refer to
    /// we just simple drop the extra data
    pub fn pstd_type_instance_write(
        inst: *mut pstd_type_instance_t,
        accessor: pstd_type_accessor_t,
        buf: *const ::std::os::raw::c_void,
        bufsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Get the constant defined by the type of the given pipe
    /// @param model The type model
    /// @param pipe The pipe
    /// @param field The field name
    /// @param is_signed Is the number signed
    /// @param is_real Is the number a real number
    /// @param buf The target buffer
    /// @param bufsize The target buf size
    /// @return status code
    pub fn pstd_type_model_const(
        model: *mut pstd_type_model_t,
        pipe: pipe_t,
        field: *const ::std::os::raw::c_char,
        is_signed: ::std::os::raw::c_int,
        is_real: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        bufsize: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Get the size of the field
    /// @param inst The type instance
    /// @param accessor The accessor
    /// @return the size or error code
    pub fn pstd_type_instance_field_size(
        inst: *mut pstd_type_instance_t,
        accessor: pstd_type_accessor_t,
    ) -> usize;
}
/// @brief The patch field initialization param
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pstd_type_model_init_param_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_anon_1: pstd_type_model_init_param_t__bindgen_ty_1,
    /// < The field accessor
    pub field_expr: *const ::std::os::raw::c_char,
    /// < The target pipe
    pub pipe: pipe_t,
    /// < The file name
    pub filename: *const ::std::os::raw::c_char,
    /// < The line
    pub line: u32,
    /// < The pipe name
    pub pipe_name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pstd_type_model_init_param_t__bindgen_ty_1 {
    /// < The buffer used for the field accessor
    pub accessor_buf: *mut pstd_type_accessor_t,
    /// < The constant buffer
    pub const_buf: pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1 {
    /// < The target address
    pub target_addr: *mut ::std::os::raw::c_void,
    /// < The size of the constant
    pub const_size: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1>()))
                .target_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(target_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1>()))
                .const_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(const_size)
        )
    );
}
impl pstd_type_model_init_param_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn signedness(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_signedness(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn floatpoint(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_floatpoint(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        signedness: u8,
        floatpoint: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let signedness: u8 = unsafe { ::std::mem::transmute(signedness) };
            signedness as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let floatpoint: u8 = unsafe { ::std::mem::transmute(floatpoint) };
            floatpoint as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pstd_type_model_init_param_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pstd_type_model_init_param_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_type_model_init_param_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t__bindgen_ty_1>())).accessor_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1),
            "::",
            stringify!(accessor_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t__bindgen_ty_1>())).const_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t__bindgen_ty_1),
            "::",
            stringify!(const_buf)
        )
    );
}
#[test]
fn bindgen_test_layout_pstd_type_model_init_param_t() {
    assert_eq!(
        ::std::mem::size_of::<pstd_type_model_init_param_t>(),
        64usize,
        concat!("Size of: ", stringify!(pstd_type_model_init_param_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstd_type_model_init_param_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstd_type_model_init_param_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t>())).field_expr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t),
            "::",
            stringify!(field_expr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t>())).pipe as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t),
            "::",
            stringify!(pipe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t>())).filename as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t>())).line as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pstd_type_model_init_param_t>())).pipe_name as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pstd_type_model_init_param_t),
            "::",
            stringify!(pipe_name)
        )
    );
}
impl pstd_type_model_init_param_t {
    #[inline]
    pub fn is_constant(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_constant(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_constant: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_constant: u8 = unsafe { ::std::mem::transmute(is_constant) };
            is_constant as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    /// @brief Perform the batch type model initialization
    /// @param params The initialzation param array initialized with PSTD_TYPE_MODEL_* macro
    /// @param count The size of the array
    /// @param model If this variable is given using the type model instead of the new one
    /// @return The created type model
    pub fn pstd_type_model_batch_init(
        params: *const pstd_type_model_init_param_t,
        count: usize,
        model: *mut pstd_type_model_t,
        ...
    ) -> *mut pstd_type_model_t;
}
extern "C" {
    /// @brief Try to read the library configuration dynamically, this can be changed by
    /// PSS code:
    /// plumber.std.libconf.&lt;key&gt; = xxxx
    /// If the system can not tell the value, use the default value provided in the param
    /// @param key The key to read
    /// @param default_val The defualt value
    /// @return the value
    pub fn pstd_libconf_read_numeric(key: *const ::std::os::raw::c_char, default_val: i64) -> i64;
}
extern "C" {
    /// @brief Try to read the string configuration, this function is similar to the numeric version
    /// @param key The key to read
    /// @param default_val The defualt value
    /// @return The value has been loaded
    pub fn pstd_libconf_read_string(
        key: *const ::std::os::raw::c_char,
        default_val: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
