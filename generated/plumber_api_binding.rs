/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: f64 = 200809.0;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: f64 = 201505.0;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: f64 = -9223372036854776000.0;
pub const INT_FAST32_MIN: f64 = -9223372036854776000.0;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: f64 = 9223372036854776000.0;
pub const INT_FAST32_MAX: f64 = 9223372036854776000.0;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: f64 = -9223372036854776000.0;
pub const INTPTR_MAX: f64 = 9223372036854776000.0;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: f64 = -9223372036854776000.0;
pub const PTRDIFF_MAX: f64 = 9223372036854776000.0;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_GET_FLAGS: u32 = 4278190080;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_SET_FLAG: u32 = 4278190081;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_CLR_FLAG: u32 = 4278190082;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_EOM: u32 = 4278190083;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_PUSH_STATE: u32 = 4278190084;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_POP_STATE: u32 = 4278190085;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_INVOKE: u32 = 4278190086;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_READHDR: u32 = 4278190087;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_WRITEHDR: u32 = 4278190088;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_MODPATH: u32 = 4278190089;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_GET_HDR_BUF: u32 = 4278190090;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_GET_DATA_BUF: u32 = 4278190091;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_PUT_DATA_BUF: u32 = 4278190092;
pub const RUNTIME_API_PIPE_CNTL_OPCODE_NOP: u32 = 4294967294;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_SET_WAIT: u32 = 0;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_NOTIFY_WAIT: u32 = 1;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_RETCODE: u32 = 2;
pub const RUNTIME_API_ASYNC_CNTL_OPCODE_CANCEL: u32 = 3;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
/// @brief the type used to the pipe ID
pub type runtime_api_pipe_id_t = u16;
/// @brief the type used to represent a pipe object, either a real pipe or a reference
///        to a module function
/// @note there are two different memory layout for this type <br/>
///       a) 11111111 00000000 pppppppp pppppppp <br/>
///          This is used when we refer a pipe id <br/>
///       b) mmmmmmmm oooooooo oooooooo oooooooo <br/>
///          This is used when we refer a service module function
pub type runtime_api_pipe_t = u32;
/// @brief the type used for the pipe define flags
///  @note the bit layout of a pipe flags is  <br/>
///        rrrrrrrr rrrDsapd tttttttt tttttttt <br/>
///        D = disabled <br/>
///        s = Shadow Pipe <br/>
///        a = Async Pipe <br/>
///        r = Reserved <br/>
///        p = Presist  <br/>
///        d = Pipe direction <br/>
///        t = Target Pipe <br/>
pub type runtime_api_pipe_flags_t = u32;
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_POS),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_INPUT_CHECK_NEG),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_POS),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_PIPE_OUTPUT_CHECK_NEG),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_flags_dir1 {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_flags_dir1() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_flags_dir1>(),
        0usize,
        concat!("Size of: ", stringify!(__const_checker_eq_flags_dir1))
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_flags_dir1>(),
        4usize,
        concat!("Alignment of ", stringify!(__const_checker_eq_flags_dir1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_flags_dir1>())).test as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_flags_dir1),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_flags_dir2 {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_flags_dir2() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_flags_dir2>(),
        0usize,
        concat!("Size of: ", stringify!(__const_checker_eq_flags_dir2))
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_flags_dir2>(),
        4usize,
        concat!("Alignment of ", stringify!(__const_checker_eq_flags_dir2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_flags_dir2>())).test as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_flags_dir2),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_flags_persist {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_flags_persist() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_flags_persist>(),
        0usize,
        concat!("Size of: ", stringify!(__const_checker_eq_flags_persist))
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_flags_persist>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_flags_persist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_flags_persist>())).test as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_flags_persist),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_get_flags__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_get_flags__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_get_flags__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_get_flags__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_get_flags__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_get_flags__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_get_flags__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_get_flags__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_set_flag__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_set_flag__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_set_flag__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_set_flag__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_set_flag__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_set_flag__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_set_flag__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_set_flag__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_clr_flag__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_clr_flag__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_clr_flag__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_clr_flag__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_clr_flag__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_clr_flag__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_clr_flag__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_clr_flag__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_eom__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_eom__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_eom__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_eom__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_eom__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_eom__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_eom__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_eom__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_push_state__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_push_state__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_push_state__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_push_state__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_push_state__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_push_state__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_push_state__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_push_state__),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq___non_module_related_pop_state__ {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq___non_module_related_pop_state__() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq___non_module_related_pop_state__>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq___non_module_related_pop_state__)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq___non_module_related_pop_state__>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq___non_module_related_pop_state__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq___non_module_related_pop_state__>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq___non_module_related_pop_state__),
            "::",
            stringify!(test)
        )
    );
}
/// @brief the token used to request local scope token
pub type runtime_api_scope_token_t = u32;
/// @brief The event description of the event driven scope stream. Which is actually a file descriptor and
///        when the file descriptor should be treated as the stream gets ready
///        If both read and write is 0, it means we want to remove the event from the module
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_scope_ready_event_t {
    ///< The FD that is used for event notification
    pub fd: ::std::os::raw::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    ///< The time limit for the RLS token not gets ready
    pub timeout: i32,
}
#[test]
fn bindgen_test_layout_runtime_api_scope_ready_event_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_scope_ready_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(runtime_api_scope_ready_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_scope_ready_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(runtime_api_scope_ready_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_ready_event_t>())).fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_ready_event_t),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_ready_event_t>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_ready_event_t),
            "::",
            stringify!(timeout)
        )
    );
}
impl runtime_api_scope_ready_event_t {
    #[inline]
    pub fn read(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(read: u32, write: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read: u32 = unsafe { ::std::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write: u32 = unsafe { ::std::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit
    }
}
/// @brief Represent an entity in the scope. It's actually a group of callback function for the opeartion
///        that is supported by the scope entity and a memory address which represent the entity data
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_scope_entity_t {
    ///< the actual pointer
    pub data: *mut ::std::os::raw::c_void,
    /// @brief the callback function used to copy the memory
    /// @param ptr the pointer to copy
    /// @return the copied pointer
    pub copy_func: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    /// @brief the callback used to dispose a managed pointer
    /// @note this is the only required callback for each RLS object
    /// @param ptr the pointer to dispose
    /// @return status code
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief the callback function used to open the rscope pointer as a byte stream
    /// @note this is the callback function is used to serialize the RLS memory info a
    ///       byte stream. This feature is used for the framework to write a serialized
    ///       RLS directly to the pipe, which means we do not needs high level user-space
    ///       program to handle this. <br/>
    ///       The reason for why we have this is, without this mechanism,
    ///       when we build a file server, we need to read the file content into a mem pipe,
    ///       and then copy the mem pipe to async buffer and then write it to the socket.
    ///       Most of the operations are unncessary. By introducing the file RLS, and this
    ///       byte stream interface, we will be able to read the file from the async write loop
    ///       directly. In this way, we can elimite the memory copy completely. <br/>
    /// @param ptr the RLS pointer to open
    /// @return the byte stream handle, which is the state variable for the serialization, NULL on error case
    pub open_func: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    /// @brief read bytes from the byte stream representation of the RLS pointer
    /// @param handle the byte stream handle
    /// @param buffer the buffer to return the read result
    /// @param bufsize the buffer size
    /// @return the bytes has been read to buffer, or error code
    /// @note If this function returns 0, it may indicates the stream is waiting for resource gets ready
    ///       In this case, if the user supports event driven interface, it may call event_func for the
    ///       event description that hints the availibility of the stream.
    pub read_func: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_void,
            bufsize: usize,
        ) -> usize,
    >,
    /// @brief check if the byte stream representation of the RLS pointer has reached the end of stream (EOS)
    /// @param handle the byte stream handle
    /// @return the check result, 1 for true, 0 for false, error code on error cases
    pub eos_func: ::std::option::Option<
        unsafe extern "C" fn(handle: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief Get the event that should be used as the notification for the readiness of the stream
    /// @param handle The stream handle
    /// @param event_buf The buffer used to return the event
    /// @return Number of event has been registered, 0 if no event should be registered, 1 for needs to register one
    ///         event and error code for all the error cases
    pub event_func: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            event_buf: *mut runtime_api_scope_ready_event_t,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief close a used stream handle
    /// @param handle the handle to close
    /// @note this function will dispose the memory occupied by the handle
    /// @return status code
    pub close_func: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_scope_entity_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_scope_entity_t>(),
        64usize,
        concat!("Size of: ", stringify!(runtime_api_scope_entity_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_scope_entity_t>(),
        8usize,
        concat!("Alignment of ", stringify!(runtime_api_scope_entity_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).copy_func as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(copy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).free_func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(free_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).open_func as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(open_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).read_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(read_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).eos_func as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(eos_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).event_func as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(event_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_entity_t>())).close_func as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_entity_t),
            "::",
            stringify!(close_func)
        )
    );
}
/// @brief describe the param for the request that ask for the write_token API consume the
///        token data in the way specified by this
/// @details Problem: This mechanism is used to address the problem that the directly RLS token access interface
///         is not buffer friendly. Consider we use an BIO object to write the pipe, so all the data that has written
///         to pipe via BIO is bufferred in the BIO buffer. After this, if we want to write a RLS token, the BIO buffer
///         has to flush no matter if it's full or not. <br/>
///         Because the write_token call do not aware of the BIO buffer, so it will write the data directly, however all
///         the bufferred BIO data which should be written before the token is now after the token content. <br/>
///         However, this additional flush causes serious problem. Because we have to flush the buffer once the write_token has
///         been called. For example, previously, we will be able to use the bio call like:
///         <code>
///         		pstd_bio_printf("<div>%s</div>", file_content);
///         </code>
///         To write the response which will translate to 1 pipe_write of course, however, by introducing the DRA, we should use:
///         <code>
///         		pstd_bio_printf("<div>");
///         		pstd_bio_write_token(file_token);
///         		pstd_bio_printf("</div>");
///         </code>
///         Which actually needs to translate to 3 pipe_write, which turns out to be 3 syscalls. <br/>
///         This causes a huge performance downgrade from 115K Req/sec to 68K req/sec for the user-agent echo back server.
///         Solution: This is the descriptor that request the first N bytes from the RLS token stream, and this data will be passed in
///         to the callback provided by the caller of write_token, by having this callback, the caller (which is PSTD BIO of course),
///         will have a last chance to fill the unused buffer. If the stream is exhuasted by the data request, no underlying DRA will
///         happen, otherwise, the DRA will handle the remaining portion of the stream. <br/>
///         If the data is exhuasted by the data request and BIO buffer is not full, then the buffer won't flush. In this way, we make
///         a full use of user-space buffer before we flush it.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_scope_token_data_request_t {
    ///< The number of bytes we are reqeusting
    pub size: usize,
    ///< The caller context of this data request
    pub context: *mut ::std::os::raw::c_void,
    /// @brief the callback function that handles the requested data, it may be called multiple times
    ///        once the data_handler returns 0, then it means the data request do not want the data anymore
    /// @param context the caller defined context
    /// @param data the pointer to the data section
    /// @param count the number of bytes is available at this time
    /// @return the number of bytes handled by this call, if the return value is larger than 0 and the requested size
    ///         limit not reach, then the remaning data from the token stream will keep sent to the handler, until
    ///         it returns an error code or 0
    pub data_handler: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            data: *const ::std::os::raw::c_void,
            count: usize,
        ) -> usize,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_scope_token_data_request_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_scope_token_data_request_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(runtime_api_scope_token_data_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_scope_token_data_request_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(runtime_api_scope_token_data_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_token_data_request_t>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_token_data_request_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_token_data_request_t>())).context as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_token_data_request_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_scope_token_data_request_t>())).data_handler
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_scope_token_data_request_t),
            "::",
            stringify!(data_handler)
        )
    );
}
/// @brief The callback when the type of the pipe is determined
/// @param pipe the pipe descriptor
/// @param type_name the concrete type name of the pipe
/// @param data the addtional data passed to the callback, typically the servlet instance context
/// @return status code
pub type runtime_api_pipe_type_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        pipe: runtime_api_pipe_t,
        type_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
///< This is a sync servlet
pub const RUNTIME_API_INIT_RESULT_SYNC: _bindgen_ty_1 = 0;
///< This is an async servlet
pub const RUNTIME_API_INIT_RESULT_ASYNC: _bindgen_ty_1 = 1;
/// @brief The return value for the servlet's init function, which indicates the property of the servlet
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Debug)]
pub struct __const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC {
    pub test: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout___const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC() {
    assert_eq!(
        ::std::mem::size_of::<__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC>())).test
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__const_checker_eq_RUNTIME_API_INIT_RESULT_SYNC),
            "::",
            stringify!(test)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _runtime_api_async_task_handle_t {
    _unused: [u8; 0],
}
/// @brief This is the dummy type we used to make the compiler aware we are dealing with a async task handle
pub type runtime_api_async_handle_t = _runtime_api_async_task_handle_t;
/// @brief the address table that contains the address of the pipe APIs
/// @note we do not need the servlet instance id, because the caller of the exec of the init will definately have the execution info. <br/>
///       All the function defined in this place can only be called within the servlet context. <br/>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_address_table_t {
    /// @brief define a named pipe in the PDT of this servlet
    /// @details Define a IO pipe for a servlet. The function will define a pipe for a servlet.
    ///         Which is actually either the input or the output end of a pipe. <br/>
    ///         The function will return a integer called pipe descriptor. The pipe descriptor can be
    ///         used later in the exec function of the servlet as the data source/sink. <br/>
    ///         For the given servlet instance, once the instance is initialized, the servlet can not
    ///         define the pipe anymore. <br/>
    ///         The reason for why we need such limitation is the topologic structure of a service *must*
    ///         be defined before the framework start serving traffic. Which means, we do not allow the
    ///         node change it's layout after the initialization pharse. <br/>
    ///         Also, the pipe can be defined with different properties. The properties can be changed at
    ///         the execution pharse for *only that exuection*. Which means you can not preserve the pipe
    ///         flags changed in execution phrase.
    /// @note This function must be called by the **init** function in servlet
    /// @param name the name to this pipe
    /// @param flag the flag to create this pipe
    /// @param type_expr the type expression for this pipe, if NULL is given, then this is a untyped pipe
    /// @return pipe id or a negative error code
    pub define: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            flag: runtime_api_pipe_flags_t,
            type_expr: *const ::std::os::raw::c_char,
        ) -> runtime_api_pipe_t,
    >,
    /// @brief setup the hook function when the type of pipe is determined. The reason for having this function is
    ///        that we have some generic typed servlet. So the type of the pipe is depends on the context of the service
    ///        graph, rather than the servlet itself. So that we do not know the concrete type of the generic pipe until
    ///        we finished the type inference. <br/>
    ///        However, we don't want to query the type info in exeuction time, because of the perofmrance consideration.
    ///        So we should have some mechanism so that we can initialize the type specified information before the servlet
    ///        actually started.
    /// @param callback the callback function pointer
    /// @param pipe     the pipe descriptor we want to set the callback
    /// @param data     the additional data to be passed to the callback function
    /// @note  Because the type inferrer only work on the assigned pipes, so even though the type of unassigned pipes are known
    ///        the callback function won't be called.
    /// @return status code
    /// @todo implement this
    pub set_type_hook: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            callback: runtime_api_pipe_type_callback_t,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief read data from pipe
    /// @param pipe the pipe to read
    /// @param nbytes the number of bytes to read
    /// @param buffer the memory buffer for the read result
    /// @return either the number of bytes or the error code
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            buffer: *mut ::std::os::raw::c_void,
            nbytes: usize,
        ) -> usize,
    >,
    /// @brief write data to the given pipe
    /// @param pipe the pipe to write
    /// @param data the data buffer
    /// @param nbytes the number of bytes to write
    /// @return number of bytes has written
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            data: *const ::std::os::raw::c_void,
            nbytes: usize,
        ) -> usize,
    >,
    /// @brief write the content of a scope token to the pipe
    /// @details The detailed description can be found in the documentation of the module call write_callback
    /// @param pipe the pipe to write
    /// @param token the token
    /// @param data_req the data request callback, see the type documentation for the details about the data request mechanism.
    ///                 If the data request is not desired, pass just NULL. During this time, no pointer's ownership will be taken
    /// @note this function will make sure that all the bytes for this token is written to the pipe
    /// @return status code
    pub write_scope_token: ::std::option::Option<
        unsafe extern "C" fn(
            pipe: runtime_api_pipe_t,
            token: runtime_api_scope_token_t,
            data_req: *const runtime_api_scope_token_data_request_t,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief write a log to the plumber logging system
    /// @param level the log level
    /// @param file  the source code file name
    /// @param function the function name
    /// @param line the line number
    /// @param fmt the formatting string
    /// @param ap the vaargs
    /// @return nothing
    pub log_write: ::std::option::Option<
        unsafe extern "C" fn(
            level: ::std::os::raw::c_int,
            file: *const ::std::os::raw::c_char,
            function: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            ap: *mut __va_list_tag,
        ),
    >,
    /// @brief trap is a function that makes the execution flow goes back to the Plumber framework
    /// @param id the trap id
    pub trap: ::std::option::Option<unsafe extern "C" fn(id: ::std::os::raw::c_int)>,
    /// @brief EOF check
    /// @param pipe the pipe id
    /// @return result or status code
    pub eof: ::std::option::Option<
        unsafe extern "C" fn(pipe: runtime_api_pipe_t) -> ::std::os::raw::c_int,
    >,
    /// @brief the pipe control API
    /// @note this function is used to control pipe behaviour, like POSIX API fcntl. This function
    ///       modifies the current pipe instance only, and do not affect any other pipe instnaces.
    /// @param pipe the target pipe
    /// @param opcode what operation needs to be perfomed
    /// @param ap the va params
    /// @return the status code
    pub cntl: ::std::option::Option<
        unsafe extern "C" fn(pipe: runtime_api_pipe_t, opcode: u32, ap: *mut __va_list_tag)
            -> ::std::os::raw::c_int,
    >,
    /// @brief requires a module function handle pipe so that the servlet can call the service module
    /// @param mod_name the name of the service module function, e.g. "mempool.object_pool"
    /// @param func_name the name of the function we want, e.g. "allocate"
    /// @return the module type code
    pub get_module_func: ::std::option::Option<
        unsafe extern "C" fn(
            mod_name: *const ::std::os::raw::c_char,
            func_name: *const ::std::os::raw::c_char,
        ) -> runtime_api_pipe_t,
    >,
    /// @brief open a module by its name
    /// @param mod the name of the module
    /// @note this function must match the exact module path
    /// @return the module type code or error code
    pub mod_open:
        ::std::option::Option<unsafe extern "C" fn(mod_: *const ::std::os::raw::c_char) -> u8>,
    /// @brief get the 8bit prefix used for the module specified cntl opcode
    /// @param path the path to the module suffix, for example all the TLS module should use "pipe.tls"
    /// @param result the result prefix, if there's no module instace under the given path, the result will be set to ERROR_CODE(uint8_t)
    /// @note The reason why we need this function is: <br/>
    ///       1. The module is dynmaically loaded, so the module id is determined in runtime <br/>
    ///       2. The servlet API is module-implementation-transparent, which means we cannot put any pipe implementation specified code in the
    ///          servlet code <br/>
    ///       In some cases, we may have serveral module instatiated from the same module binary
    ///       with different module initializtion param.
    ///       In this case, if we need to call the module specified control opcode, we *have to* know
    ///       the module id, because the opcode for module specified opcode is &lt;module-id, module-specfied-opcode&gt; <br/>
    ///       The module id can be get from mod_open call, however, it requires a full path to the module instance. This
    ///       makes the details of the pipe not transparent to the servlet. <br/>
    ///       For example, in code we may want to disable the TLS encrpytion because of the oppurtunistic encryption.
    ///       On the server which is configured the TLS module is listening to the port 443. With mod_open call, we have to
    ///       make the code like:
    ///       \code{.c}
    ///       	uint8_t mod = mod_open("pipe.tls.pipe.tcp.port_443");
    ///       	uint32_t opcode = (mod << 24) | (OPCODE_WE_WANT);
    ///       	pipe_cntl(pipe, opcode, ....);
    ///       \endcode
    ///       As we can see from the code, once the port gets changed, the servlet doesn't work anymore.
    ///       So it's not pipe transparent. <br/>
    ///       To address this issue, we actually use *one representitive of all the module instances that is initialized from the same module binary*.
    ///       Because all the module binary are the same, so the ITC framework will be able to call the correct module binary.
    ///       At the same time, because the pipe itself has a reference to the module instance context, so the call will be forwarded correctly. <br/>
    ///       On the other hand, it's reasonable for all the module instance from same binary (e.g. all the TLS modules) to have the same opcode
    ///       because it's reasonable to have all those module instances gets the same opcode. <br/>
    ///       Based on the reason above we need the function that can return a "representitive module instance" for all the module which creates from the
    ///       same module binary. <br/>
    ///       In this function, we need assume that all the module instances under the given path are created from the same module binary.
    ///       If this rule breaks, it will return an error code
    /// @return status code
    pub mod_cntl_prefix: ::std::option::Option<
        unsafe extern "C" fn(path: *const ::std::os::raw::c_char, result: *mut u8)
            -> ::std::os::raw::c_int,
    >,
    /// @brief get the plumber version number
    /// @return the plumber version number string, NULL on error
    pub version: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    /// @brief The async task control function
    /// @note This function is the only plumber API can be called from the async processing thread.
    ///       And we actually have the limit for this function is we should call this function with task context,
    ///       otherwise we should provide the task_handle (The example for this case is the ASYNC_CNTL_OPCODE_NOTIFY_WAIT,
    ///       which we may not call the function from the thread working on the async task. In this case, we just extract
    ///       the async context from the handle
    /// @todo implement this
    /// @return status code
    pub async_cntl: ::std::option::Option<
        unsafe extern "C" fn(
            async_handle: *mut runtime_api_async_handle_t,
            opcode: u32,
            ap: *mut __va_list_tag,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_address_table_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_address_table_t>(),
        112usize,
        concat!("Size of: ", stringify!(runtime_api_address_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_address_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(runtime_api_address_table_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).define as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(define)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).set_type_hook as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(set_type_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).read as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).write as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).write_scope_token as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(write_scope_token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).log_write as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(log_write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).trap as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(trap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_address_table_t>())).eof as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).cntl as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(cntl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).get_module_func as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(get_module_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).mod_open as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(mod_open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).mod_cntl_prefix as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(mod_cntl_prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).version as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_address_table_t>())).async_cntl as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_address_table_t),
            "::",
            stringify!(async_cntl)
        )
    );
}
/// @brief the data structure used to define a servlet
/// @note  Instead of checking if the callback fuction is defined to determine if this is an async task. We relies on the
///        return value of the init function. This is because for the language support servlet, we can not tell if it's a
///        async servlet or not during the compile time. The only way for us to kown this is get the servlet fully initialized<br/>
///        If the init function returns RUNTIME_API_INIT_RESULT_SYNC and exec function has been defined, all the async_* function
///        won't be used any mopre. This case indicates we have a sync servlet. <br/>
///        If the init function returns RUNTIME_API_INIT_RESULT_ASYNC, asyc_init must be defined
///        This case indicates we have an async servlet <br/>
///        The async_exec and async_cleanup function is not necessarily to be defined. Because for some case, we
///        actually can have a task initialize a async IO form the async_init and set the async task mode to the wait mode
///        Then we can have an undefined async_exec function, which means we don't need to do anything other than initializing
///        the IO. <br/>
///        If the exec function is not defined and init returns RUNTIME_API_INIT_RESULT_SYNC, this indicates we have an sync servlet
///        with an empty exec function. This is useful when we only have a shadow output for the servlet, for example, dataflow/dup.
/// @todo  When a servlet is loaded we should
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct runtime_api_servlet_def_t {
    ///< the size of the additional data for this servlet
    pub size: usize,
    ///< the description of this servlet
    pub desc: *const ::std::os::raw::c_char,
    ///< the required API version for this servlet, currently is 0
    pub version: u32,
    /// @brief The function that will be called by the initialize task
    /// @param argc the argument count
    /// @param argv the value list of arguments
    /// @param data the servlet local data that needs to be intialized
    /// @return The servlet property flags, or error code
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            argc: u32,
            argv: *const *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief the function that will be called by the execution task
    /// @param data the servlet local data
    /// @return status code
    pub exec: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    /// @brief the function that will be called by the finalization task
    /// @param data the local data that need to be handled by the servlet
    /// @return status code
    pub unload: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    ///< The async buffer size
    pub async_buf_size: u32,
    /// @brief The initialization stage of the async task
    /// @param task This is the handle we used to pass to the async_cntl funciton
    /// @param data The servlet local context
    /// @param async_buf The buffer we are going to carry to the async_exec
    /// @note For the async_exec function, we don't allow the servlet access any servlet context,
    ///       because this breaks the thread convention of the worker thread.
    ///       This make the async task has to copy all the required data to the async buf, which is
    ///       complete different memory, and this memory will be the only data the async_exec function
    ///       can access
    /// @return status code
    pub async_setup: ::std::option::Option<
        unsafe extern "C" fn(
            task: *mut runtime_api_async_handle_t,
            async_buf: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief Execute the initialized async task, the only input of the async buf is the async buf
    ///        In this function, all the API calls are disallowed.
    /// @param async_buf The async data buffer
    /// @param task This is the handle we used to pass to the async_cntl funciton
    /// @return status code
    pub async_exec: ::std::option::Option<
        unsafe extern "C" fn(
            task: *mut runtime_api_async_handle_t,
            async_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// @brief Clean the used async data
    /// @param data The servlet local context data
    /// @param task_handle This is the handle we used to pass to the async_cntl funciton
    /// @return status code
    pub async_cleanup: ::std::option::Option<
        unsafe extern "C" fn(
            task: *mut runtime_api_async_handle_t,
            async_data: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_runtime_api_servlet_def_t() {
    assert_eq!(
        ::std::mem::size_of::<runtime_api_servlet_def_t>(),
        80usize,
        concat!("Size of: ", stringify!(runtime_api_servlet_def_t))
    );
    assert_eq!(
        ::std::mem::align_of::<runtime_api_servlet_def_t>(),
        8usize,
        concat!("Alignment of ", stringify!(runtime_api_servlet_def_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).version as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).exec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(exec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).unload as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_buf_size as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_setup as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_setup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_exec as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_exec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<runtime_api_servlet_def_t>())).async_cleanup as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(runtime_api_servlet_def_t),
            "::",
            stringify!(async_cleanup)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
